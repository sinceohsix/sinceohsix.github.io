<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>~/ — File Browser</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* === BASIC / THEME === */
    :root{
      --bg:#fafafa; --fg:#111; --panel:#fff; --muted:#666; --accent:#0077cc; --divider:#cfcfcf;
      --ui-radius:6px;
    }
    @media (prefers-color-scheme:dark){
      :root{
        --bg:#0b0b0b; --fg:#eaeaea; --panel:#111; --muted:#aaa; --accent:#4ea8ff; --divider:#333;
      }
    }
    html,body{height:100%; margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color:var(--fg); background:var(--bg);}
    a { color:var(--fg); text-decoration:none; }
    a.small { color:var(--muted); font-size:0.9rem; }
    h1{font-size:1.1rem;margin:12px 0;}
    /* === LAYOUT: split with draggable divider === */
    .shell {
      display:flex;
      height:100vh;
      box-sizing:border-box;
      gap:0;
      align-items:stretch;
      padding:10px;
      max-width:1200px;
      margin:0 auto;
    }

    /* left browser panel */
    .browser {
      flex:0 0 360px; /* initial width */
      min-width:120px;
      max-width:calc(100% - 120px);
      background:var(--panel);
      border:1px solid var(--divider);
      border-radius:0;
      padding:12px;
      box-sizing:border-box;
      overflow:auto;
    }

    /* divider */
    .divider {
      width:8px;
      cursor:col-resize;
      background:linear-gradient(90deg, transparent, rgba(0,0,0,0.02), transparent);
      display:flex; align-items:center; justify-content:center;
    }
    .divider .grip {
      width:24px; height:60px; display:block;
      border-left:2px solid var(--divider); border-right:2px solid var(--divider);
      box-sizing:border-box;
    }

    /* preview panel */
    .preview-panel {
      flex:1 1 0;
      background:var(--panel);
      border:1px solid var(--divider);
      border-left:none;
      padding:8px;
      box-sizing:border-box;
      overflow:auto;
      display:flex;
      flex-direction:column;
    }

    /* header / path */
    .toprow { display:flex; align-items:center; gap:12px; margin-bottom:6px; }
    .path { font-size:0.95rem; color:var(--muted); }

    /* directory tree */
    .tree { padding-left:0; margin:0; }
    .tree ul { list-style:none; padding-left:12px; margin:6px 0; }
    .node { display:flex; gap:8px; align-items:center; padding:6px 6px; border-radius:4px; user-select:none; }
    .node:hover { background:rgba(0,0,0,0.02); }
    .icon {
      width:28px; height:28px; object-fit:contain; flex:0 0 28px;
    }
    .name { font-size:0.95rem; color:var(--fg); }
    .meta { font-size:0.85rem; color:var(--muted); margin-left:auto; }

    /* FOLDER: chevron style */
    .chev { width:14px; height:14px; display:inline-block; transform:rotate(0); transition:transform .18s ease; margin-right:6px; }
    .expanded > .chev { transform:rotate(90deg); }

    /* animated collapse */
    .children { overflow:hidden; transition:max-height .28s ease; max-height:0; }
    .expanded > .children { max-height:2000px; } /* large enough for deep lists */

    /* preview content */
    .preview-header { display:flex; gap:8px; align-items:center; border-bottom:1px solid var(--divider); padding-bottom:8px; margin-bottom:8px; }
    .preview-body { flex:1 1 auto; overflow:auto; padding:8px; }
    pre { white-space:pre-wrap; word-break:break-word; background:rgba(0,0,0,0.03); padding:10px; border-radius:4px; overflow:auto; }
    img.preview { max-width:100%; height:auto; display:block; border:1px solid var(--divider); border-radius:4px; }
    audio { width:100%; outline:none; margin-top:8px; }

    /* smaller screens stack vertically and allow vertical drag */
    @media (max-width:800px){
      .shell { flex-direction:column; padding:8px; }
      .browser { width:100%; height:42vh; max-height:50vh; overflow:auto; }
      .divider { height:8px; width:100%; cursor:row-resize; display:flex; }
      .divider .grip { width:60px; height:16px; border-top:2px solid var(--divider); border-bottom:2px solid var(--divider); }
      .preview-panel { height:calc(100vh - 42vh - 32px); min-height:220px; }
    }

    /* UI tweaks */
    .muted { color:var(--muted); font-size:0.9rem; }
    .btn { border:1px solid var(--divider); background:transparent; padding:6px 8px; border-radius:4px; cursor:pointer; font-family:inherit; }
  </style>
</head>
<body>
  <div class="shell" id="shell">
    <nav class="browser" id="browser">
      <div class="toprow">
        <h1 style="margin:0">~/</h1>
        <div style="flex:1"></div>
        <a href="#" id="refreshBtn" class="btn">Refresh</a>
      </div>
      <div id="treeWrap" class="tree" aria-live="polite">Loading manifest…</div>
    </nav>

    <div class="divider" id="divider" title="Drag to resize">
      <span class="grip" aria-hidden="true"></span>
    </div>

    <section class="preview-panel" id="previewPanel" aria-live="polite">
      <div class="preview-header">
        <div style="display:flex;align-items:center;gap:8px;">
          <img id="previewIcon" class="icon" src="icons/file.png" alt="" />
          <div>
            <div id="previewName" style="font-weight:600">No file selected</div>
            <div id="previewPath" class="muted" style="font-size:0.85rem">—</div>
          </div>
        </div>
        <div style="flex:1"></div>
        <div class="meta">
          <a id="downloadLink" class="small" href="#" download style="display:none">Download</a>
        </div>
      </div>

      <div class="preview-body" id="previewBody">
        <div class="muted">Select a file on the left to preview (text, image, mp3 supported)</div>
      </div>
    </section>
  </div>

<script>
/* ======= CONFIG ======= */
const CONTENTS_PREFIX = "contents/"; // automatically prepended to logical paths
const ICONS = {
  folder: "icons/folder.png",
  file: "icons/file.png",
  folder_white: "icons/folder_white.png",
  file_white: "icons/file_white.png"
};
/* ====================== */

let manifest = null;
const browserEl = document.getElementById("treeWrap");
const previewBody = document.getElementById("previewBody");
const previewName = document.getElementById("previewName");
const previewPath = document.getElementById("previewPath");
const previewIcon = document.getElementById("previewIcon");
const downloadLink = document.getElementById("downloadLink");

// dark mode detection for icons
const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
function pickIcon(type) {
  if (type === 'folder') return isDark ? ICONS.folder_white : ICONS.folder;
  return isDark ? ICONS.file_white : ICONS.file;
}

// fetch manifest and render
async function loadManifest() {
  try {
    const res = await fetch('manifest.json', {cache: "no-store"});
    if (!res.ok) throw new Error(`manifest fetch ${res.status}`);
    const data = await res.json();
    manifest = Array.isArray(data.items) ? data.items : (Array.isArray(data) ? data : (data.items || []));
    // Accept either {items:[...]} or just an array
    // Normalize items to {path, name}
    manifest = manifest.map(i => {
      if (typeof i === 'string') return {path: i, name: i.split('/').pop()};
      if (!i.path) return null;
      return {path: i.path.replace(/^\/+/, ''), name: i.name || i.path.split('/').pop()};
    }).filter(Boolean);

    const tree = buildTree(manifest);
    browserEl.innerHTML = '';
    browserEl.appendChild(renderTree(tree));
    // If URL has ?path= something open preview
    const urlPath = new URLSearchParams(location.search).get('path');
    if (urlPath) {
      openPreview(urlPath);
      // try to expand the folder chain to reveal file in tree
      expandToPath(urlPath);
    }
  } catch (err) {
    browserEl.textContent = "Error loading manifest: " + err;
    console.error(err);
  }
}

/* Build tree structure from file paths
   returns object where keys are folder/file names and value:
   { type: 'folder'|'file', children: {...}, data: {path,name}}
*/
function buildTree(items) {
  const root = {};
  for (const it of items) {
    const parts = it.path.split('/').filter(Boolean);
    let node = root;
    for (let i=0; i<parts.length; i++) {
      const name = parts[i];
      const isFile = i === parts.length - 1 && name.includes('.');
      if (!node[name]) node[name] = { type: isFile ? 'file' : 'folder', children: {}, data: null };
      if (isFile) node[name].data = it;
      node = node[name].children;
    }
  }
  return root;
}

/* Render tree recursively */
function renderTree(tree, depth=0) {
  const ul = document.createElement('ul');
  for (const [name, node] of Object.entries(tree)) {
    const li = document.createElement('li');

    const row = document.createElement('div');
    row.className = 'node';
    row.style.paddingLeft = (depth * 12) + 'px'; // indent visually

    // chevron for folders
    const chev = document.createElement('span');
    chev.className = 'chev';
    chev.innerHTML = node.type === 'folder' ? '&#9654;' : ''; // triangle
    row.appendChild(chev);

    // icon
    const img = document.createElement('img');
    img.className = 'icon';
    img.src = node.type === 'folder' ? pickIcon('folder') : pickIcon('file');
    img.alt = node.type;
    row.appendChild(img);

    // name
    const nameEl = document.createElement('span');
    nameEl.className = 'name';
    nameEl.textContent = name;
    row.appendChild(nameEl);

    // meta placeholder
    // const meta = document.createElement('span'); meta.className='meta'; row.appendChild(meta);

    li.appendChild(row);

    if (node.type === 'folder') {
      // children container
      const childWrap = document.createElement('div');
      childWrap.className = 'children';
      // initially empty; render on expand to keep DOM small
      row.onclick = (e) => {
        e.stopPropagation();
        const isExpanded = row.classList.contains('expanded');
        if (isExpanded) {
          row.classList.remove('expanded');
          // animate close
          animateCollapse(childWrap);
        } else {
          row.classList.add('expanded');
          if (!childWrap.hasChildNodes()) {
            childWrap.appendChild(renderTree(node.children, depth+1));
            // After append, animate expand
            animateExpand(childWrap);
          } else {
            animateExpand(childWrap);
          }
        }
      };
      li.appendChild(childWrap);

    } else { // file
      row.style.cursor = 'pointer';
      row.onclick = (e) => {
        e.stopPropagation();
        const logical = node.data.path;
        openPreview(logical);
        history.pushState({}, '', '?path=' + encodeURIComponent(logical));
      };
    }

    ul.appendChild(li);
  }
  return ul;
}

/* Smooth expand/collapse helpers using max-height animation */
function animateExpand(el) {
  el.style.display = 'block';
  const height = el.scrollHeight;
  el.style.maxHeight = '0px';
  // Force reflow
  el.offsetHeight;
  el.style.transition = 'max-height .28s ease';
  el.style.maxHeight = height + 'px';
  // Clear after transition
  el.addEventListener('transitionend', function te(){
    el.style.maxHeight = 'none';
    el.style.transition = '';
    el.removeEventListener('transitionend', te);
  });
}
function animateCollapse(el) {
  const height = el.scrollHeight;
  el.style.maxHeight = height + 'px';
  // Force reflow
  el.offsetHeight;
  el.style.transition = 'max-height .22s ease';
  el.style.maxHeight = '0px';
  el.addEventListener('transitionend', function tc(){
    el.style.transition = '';
    el.removeEventListener('transitionend', tc);
  });
}

/* Expand tree nodes along a path so a given file is visible */
function expandToPath(path) {
  const parts = path.split('/').filter(Boolean);
  let query = '';
  let currentList = browserEl;
  for (let i=0;i<parts.length - 1;i++){
    const part = parts[i];
    // find node row whose .name == part within currentList
    const rows = currentList.querySelectorAll(':scope > ul > li > .node');
    let foundRow=null;
    for (const r of rows) {
      const nameSpan = r.querySelector('.name');
      if (nameSpan && nameSpan.textContent === part) { foundRow = r; break; }
    }
    if (!foundRow) return;
    // simulate click to expand if not expanded
    if (!foundRow.classList.contains('expanded')) foundRow.click();
    // move currentList down one level
    const childWrap = foundRow.parentElement.querySelector('.children');
    if (!childWrap) return;
    currentList = childWrap;
  }
}

/* === Preview logic === */
function extOf(path) {
  const p = path.split('?')[0].split('#')[0];
  const part = p.split('/').pop() || '';
  const dot = part.lastIndexOf('.');
  return (dot === -1) ? '' : part.slice(dot+1).toLowerCase();
}

async function openPreview(logicalPath){
  previewName.textContent = logicalPath.split('/').pop();
  previewPath.textContent = logicalPath;
  previewIcon.src = pickIcon('file');
  downloadLink.style.display = 'none';
  previewBody.innerHTML = '<div class="muted">Loading preview…</div>';

  const real = CONTENTS_PREFIX + logicalPath;
  try {
    const res = await fetch(real);
    if (!res.ok) {
      previewBody.innerHTML = '<div class="muted">Error loading file: ' + res.status + '</div>';
      return;
    }
    const ext = extOf(logicalPath);
    if (['png','jpg','jpeg','gif','webp','svg'].includes(ext)) {
      // image
      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      const img = document.createElement('img');
      img.className='preview';
      img.src = url;
      previewBody.innerHTML = '';
      previewBody.appendChild(img);
      // cleanup object URL when not used
      img.onload = () => { URL.revokeObjectURL(url); };
      downloadLink.href = real;
      downloadLink.style.display = 'inline';
    } else if (['txt','md','json','csv','log','html','css','js'].includes(ext)) {
      const text = await res.text();
      const pre = document.createElement('pre');
      pre.textContent = text;
      previewBody.innerHTML = '';
      previewBody.appendChild(pre);
      downloadLink.href = real;
      downloadLink.style.display = 'inline';
    } else if (['mp3','wav','ogg','m4a'].includes(ext)) {
      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.src = url;
      previewBody.innerHTML = '';
      previewBody.appendChild(audio);
      // revoke after user stops? leave automatic revoke on unload
      downloadLink.href = real;
      downloadLink.style.display = 'inline';
    } else {
      // default: offer download
      previewBody.innerHTML = '<div class="muted">No preview available. Use download.</div>';
      downloadLink.href = real;
      downloadLink.style.display = 'inline';
    }
  } catch (err) {
    previewBody.innerHTML = '<div class="muted">Preview failed: ' + err + '</div>';
    console.error(err);
  }
}

/* ===== Divider (drag to resize) ===== */
const shell = document.getElementById('shell');
const divider = document.getElementById('divider');
const browserPanel = document.querySelector('.browser');
const previewPanel = document.querySelector('.preview-panel');

let dragging = false;
let dragType = 'horizontal'; // or 'vertical' for mobile stack
function startDrag(e){
  dragging = true;
  dragType = (window.innerWidth <= 800) ? 'vertical' : 'horizontal';
  document.body.style.cursor = (dragType==='horizontal' ? 'col-resize' : 'row-resize');
  e.preventDefault();
}
function stopDrag(){
  dragging = false;
  document.body.style.cursor = '';
}
function doDrag(e){
  if (!dragging) return;
  const client = (e.touches ? e.touches[0] : e).clientX;
  if (dragType === 'horizontal') {
    // calculate width for browser panel
    const rect = shell.getBoundingClientRect();
    const newWidth = Math.min(Math.max(client - rect.left - 8, 120), rect.width - 120);
    browserPanel.style.flex = '0 0 ' + newWidth + 'px';
  } else {
    // vertical mode: adjust browser height
    const clientY = (e.touches ? e.touches[0] : e).clientY;
    const rect = shell.getBoundingClientRect();
    const top = clientY - rect.top;
    const maxH = rect.height - 120;
    const h = Math.min(Math.max(top - 8, 80), maxH);
    browserPanel.style.flex = '0 0 ' + h + 'px';
  }
  e.preventDefault();
}

divider.addEventListener('mousedown', startDrag);
divider.addEventListener('touchstart', startDrag, {passive:false});
window.addEventListener('mousemove', doDrag);
window.addEventListener('touchmove', doDrag, {passive:false});
window.addEventListener('mouseup', stopDrag);
window.addEventListener('touchend', stopDrag);

/* Refresh button */
document.getElementById('refreshBtn').addEventListener('click', (e) => {
  e.preventDefault();
  loadManifest();
});

/* Back/forward support: if popstate with path open it */
window.addEventListener('popstate', () => {
  const urlPath = new URLSearchParams(location.search).get('path');
  if (urlPath) {
    openPreview(urlPath);
    expandToPath(urlPath);
  } else {
    // no path: clear preview
    previewName.textContent = 'No file selected';
    previewPath.textContent = '--';
    previewBody.innerHTML = '<div class="muted">Select a file on the left to preview (text, image, mp3 supported)</div>';
    downloadLink.style.display = 'none';
  }
});

/* initial load */
loadManifest();
</script>
</body>
</html>
